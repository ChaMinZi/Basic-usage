의존성 주입

내부에 객체를 생성해 놓기 보다는 외부에 생성하고 setter로 받는 것이 더 좋은 코드이다

안드로이드라는 프레임워크 안에서 작업을 하다 보니
--> new 를 통해서 생성해야하는데 fragment나 activity는 생성자에 객체를 주입할 수 없다
--> 이를 가능하게 해주느 것이 dagger 

dagger라는 것을 이용해서 의존성을 주입할 수 있게 된다!

** dagger를 사용하려면 사전에 작성해야 하는 것이 많다....
** Jetpack이랑 엮을려고 하면 엄청 어려워진다...

그래서 Hilt 가 나왔다 ( Dagger를 쉽게 사용할 수 있도록 개선된 Hilt )

----------------------------------------------------------
Inject를 통해서 객체가 알아서 주입된다. 

의존성 주입은 Test를 위한 것 --> 규모가 큰 프로젝트일 수록 필요하다

매번 새로운 객체를 생성한다 --> 각각의 Fragment와 Activity에 객체를 선언해두면
그런데 만약 "장바구니"와 같은 기능을 제공한다고 하면 계속 없어졌다가 생겼다가 하면서 문제가 발생할 수 있다

	- question?? 근데 사실 싱글톤으로 하면 해결되는거 아닌가? 그렇다고 한다
	- 그런데 이럴 경우 activity나 fragment를 생성할 때는 이런 방법이 안 통하자나???

주입을 받는 대상에게는 @AndroidEntryPoint이 필요

Singleton 어노테이션을 통해서 따로 내부의 코드를 구현하지 않아도 SIngleton으로 사용 가능

-------------
module을 통해서 


	- Object? Java로 따지면 class 내부에 static 메서드만 있는 것 ( class 자체로는 내용이 없는 것 )

module은 여러 개 생성 가능
따로 싱글톤 어노테이션을 만들지 않아도 @Application scope 내에서는 싱글톤으로 제공된다.

@Inject는 type을 보고 동작하기 때문에 같은 타입일 경우 다른 module이라는 것을 명시해주어야 한다.
--> Annotation을 생성해서 의존을 주입하는 곳과 주입 당하는 곳에 붙여주면 된다.

	@Retention(AnnotationRetention.RUNTIME) : 런타임에도 제공되는 Annotation이라는 뜻

-------------
viewmodel에 의존성 주입하기

1. viewmodel 생성자를 통해서 외부에서 전달하는 방법도 있지만 이는 viewmodel factory를 만드는 등 해줘야 할 것이 많기 때문에 hilt를 통해 전달하는 방법도 있다.

다른 곳에서 선언했지만 같은 객체이다

activityviewmodel과 viewmodel은 type은 같지만 다른 viewmodel이다 --> 그러나 그 안에 repository는 동일한 객체이다.
