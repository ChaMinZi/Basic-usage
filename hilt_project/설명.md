[의존성 주입 ( dependency-injection )](https://developer.android.com/training/dependency-injection)
================

### dependency-injection을 통해 얻을 수 있는 장점
	1. class의 재사용과 의존성 분리
	2. 리팩토링 편의성
	3. 테스트 편의성 	--> 규모가 큰 프로젝트일수록 의존성 주입이 필요하다.
		calss 내부에 선언되어 있는 객체를 직접 수정하는 것이 아니라 외부에서 여러 가지 객체를 삽입할 수 있어서 수정에 용의해진다. 

--------------------------------------------
## 의존성 주입이란?
* 의존성 주입이 안 된 코드
```kotlin
class Car {
    private val engine = Engine()

    fun start() {
        engine.start()
    }
}

fun main(args: Array) {
    val car = Car()
    car.start()
}
```
* 의존성 주입이 된 코드 ( **Constructor Injection - 생성자를 통한 주입** )  
```kotlin
class Car(private val engine: Engine) {
    fun start() {
        engine.start()
    }
}

fun main(args: Array) {
    val engine = Engine()
    val car = Car(engine)
    car.start()
}
```
* 의존성 주입이 된 코드 ( **Field/Setter Injection - setter를 통한 주입** )
```kotlin
class Car {
    lateinit var engine: Engine

    fun start() {
        engine.start()
    }
}

fun main(args: Array) {
    val car = Car()
    car.engine = Engine()
    car.start()
}
```

위와 같이 사용하고자 하는 Class 내부에서 객체를 생성하기 보다는 외부에서 생성하고 setter로 받는 것이 더 좋은 코드라고 한다. 
하지만 Android Framework에서는 mainActivity처럼 activity나 fragment의 생성자에 우리가 객체를 주입할 수 없는 경우가 있다.

이를 가능하게 해주는 것이 **Dagger**이다. 

Dagger를 사용하면 의존성을 주입할 수 있기는 하지만 사전에 작성해야 하는 코드도 많고 **Jetpack**과 엮으려고 하면 어려워져서 나온 것이 Hilt라는 라이브러리이다. 
Hilt는 Dagger를 좀 더 쉽게 사용할 수 있도록 개선된 공식 라이브러리로 Dagger를 기반으로 빌드되었다고 한다.


## [Hilt를 사용하여 의존성 주입하기](https://developer.android.com/training/dependency-injection/hilt-android)
[Adding dependencies](https://developer.android.com/training/dependency-injection/hilt-android#setup) 이외에도 kotlin을 사용하려면 아래의 내용을 추가해주어야 동작하였다.

```
kotlinOptions {
    jvmTarget = "1.8"
}
```

1. ```@HiltAndroidApp``` 어노테이션이 선언된 Application 클래스 만들기
2. ```@AndroidEntryPoint``` 의존하는 대상에게는 해당 어노테이션이 추가되어 있어야 한다.
3. ```@Inject``` 어노테이션을 사용하면 객체에 알아서 주입된다. 의존하는 곳(주입된 곳)과 의존되는 곳 모두에 선언해야 한다.

```kotlin
@AndroidEntryPoint
class ExampleActivity : AppCompatActivity() {

  @Inject 
  lateinit var analytics: AnalyticsAdapter
  ...
}
```
```kotlin
class AnalyticsAdapter @Inject constructor(
  private val service: AnalyticsService
) { ... }
```

_주의_

_Fields injected by Hilt cannot be private ( Hilt로 의존성을 주입한 Field는 비공개가 될 수 없다. 만약 private으로 선언하면 컴파일 에러를 만난다. )_

----------------------------------------------------------
Inject를 통해서 객체가 알아서 주입된다. 

의존성 주입은 Test를 위한 것 --> 규모가 큰 프로젝트일 수록 필요하다

매번 새로운 객체를 생성한다 --> 각각의 Fragment와 Activity에 객체를 선언해두면
그런데 만약 "장바구니"와 같은 기능을 제공한다고 하면 계속 없어졌다가 생겼다가 하면서 문제가 발생할 수 있다

	- question?? 근데 사실 싱글톤으로 하면 해결되는거 아닌가? 그렇다고 한다
	- 그런데 이럴 경우 activity나 fragment를 생성할 때는 이런 방법이 안 통하자나???

주입을 받는 대상에게는 @AndroidEntryPoint이 필요

Singleton 어노테이션을 통해서 따로 내부의 코드를 구현하지 않아도 SIngleton으로 사용 가능


## [Hilt Module](https://developer.android.com/training/dependency-injection/hilt-android#hilt-modules)

module을 통해서 

	- Object? Java로 따지면 class 내부에 static 메서드만 있는 것 ( class 자체로는 내용이 없는 것 )

module은 여러 개 생성 가능
따로 싱글톤 어노테이션을 만들지 않아도 @Application scope 내에서는 싱글톤으로 제공된다.



* ### [Hilt in multi-module apps](https://developer.android.com/training/dependency-injection/hilt-multi-module#dfm)

```@Inject```는 type을 보고 동작하기 때문에 같은 type일 경우 다른 module이라는 것을 명시해주어야 한다. 
--> Annotation을 생성해서 의존을 주입하는 곳과 주입 당하는 곳에 붙여주면 된다.

```@Retention(AnnotationRetention.RUNTIME)``` : 런타임에도 제공되는 Annotation이라는 뜻

-------------
viewmodel에 의존성 주입하기

## [ViewModel에 의존성 주입하기](https://developer.android.com/training/dependency-injection/hilt-jetpack#viewmodels)

viewmodel 생성자를 통해서 외부에서 전달하는 방법도 있지만 이는 viewmodel factory를 만드는 등 해줘야 할 것이 많기 때문에 Hilt를 통해 전달하는 방법도 있다.

다른 곳에서 선언했지만 같은 객체이다

activityviewmodel과 viewmodel은 type은 같지만 다른 viewmodel이다 --> 그러나 그 안에 repository는 동일한 객체이다.
